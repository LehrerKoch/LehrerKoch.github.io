<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Polynom Ableitung Übung</title>
<link rel="stylesheet" href="styles.css">
<link rel="stylesheet" href="scale.css">
<script src="scale.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5K8WYYXDL2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5K8WYYXDL2');
</script>
<style>
#task { font-size: 1.6em; }
#solution { color:red; font-size:1.3em }
#solutionPath {
    margin: 1em;
    border-width: thin;
}
#solutionPathContent { color:blue; font-size:1.3em }

.inner-label.disabled {
  opacity: 0.4;
}

.slider-container {
  margin: 10px 0;
}

.slider-container input[type="range"] {
  width: 200px;
}
</style>

</head>

<body>

<h1>Polynom Ableitung Übung</h1>

<details>
<summary>Einstellungen</summary>

<div class="form-block">
<b>Funktionstyp</b><br>
<label><input type="radio" name="funcType" value="power"> Nur Potenzfunktionen</label><br>
<label><input type="radio" name="funcType" value="powerWithFactor"> Potenzfunktion mit Faktorregel</label><br>
<label><input type="radio" name="funcType" value="polynomial" checked> Polynome</label><br>
</div>

<div class="form-block">
<div class="slider-container">
<b>Maximaler Grad: <span id="degreeValue">4</span></b><br>
<input type="range" id="maxDegree" min="1" max="10" value="4">
</div>
</div>

<div class="form-block">
<b>Koeffizienten</b><br>
<label><input type="checkbox" id="allowDecimals"> Dezimalzahlen erlauben</label><br>
<label><input type="checkbox" id="allowFractions"> Brüche erlauben</label><br>
</div>

<div class="form-block">
<label><input type="checkbox" id="allowFactor"> Extra Faktor vor der Funktion</label>
</div>

</details>

<button onclick="newTask()">Neue Aufgabe</button>

<h2>Aufgabe</h2>
<div class="scale-wrapper">
  <div id="task" class="scale-el"></div>
</div>

<details id="solutionDetailsContainer">
  <summary>Lösung</summary>
  <div class="scale-wrapper">
    <div id="solution" class="scale-el"></div>
  </div>
  <details id="solutionPath">
    <summary>Lösungsweg</summary>
    <div class="scale-wrapper">
      <div id="solutionPathContent" class="scale-el"></div>
    </div>
  </details>
  <br>
  <button id="stepBtn" onclick="openSteps()">Auf ableitungsrechner.de öffnen</button>
</details>

<script>
// ---------------- URL Sync ----------------
function updateURL(){
  let type = document.querySelector('input[name="funcType"]:checked').value;
  let deg = document.getElementById('maxDegree').value;
  let dec = document.getElementById('allowDecimals').checked ? 1 : 0;
  let frac = document.getElementById('allowFractions').checked ? 1 : 0;
  let fact = document.getElementById('allowFactor').checked ? 1 : 0;
  
  let url = new URL(window.location);
  url.searchParams.set('type', type);
  url.searchParams.set('degree', deg);
  url.searchParams.set('decimals', dec);
  url.searchParams.set('fractions', frac);
  url.searchParams.set('factor', fact);
  history.replaceState({}, '', url);
}

function loadURL(){
  let url = new URL(window.location);
  if(url.searchParams.has('type')){
    let type = url.searchParams.get('type');
    document.querySelector(`input[name="funcType"][value="${type}"]`).checked = true;
  }
  if(url.searchParams.has('degree')){
    document.getElementById('maxDegree').value = url.searchParams.get('degree');
    document.getElementById('degreeValue').textContent = url.searchParams.get('degree');
  }
  if(url.searchParams.has('decimals')){
    document.getElementById('allowDecimals').checked = url.searchParams.get('decimals') === '1';
  }
  if(url.searchParams.has('fractions')){
    document.getElementById('allowFractions').checked = url.searchParams.get('fractions') === '1';
  }
  if(url.searchParams.has('factor')){
    document.getElementById('allowFactor').checked = url.searchParams.get('factor') === '1';
  }
}

function syncDegreeDisplay(){
  let funcType = document.querySelector('input[name="funcType"]:checked').value;
  let slider = document.getElementById('maxDegree');
  
  // Alle Typen nutzen den gewählten Grad
  slider.max = 10;
  document.getElementById('degreeValue').textContent = slider.value;
}

loadURL();
syncDegreeDisplay();

document.querySelectorAll('input').forEach(e => e.addEventListener('change', () => {
  syncDegreeDisplay();
  updateURL();
}));

document.getElementById('maxDegree').addEventListener('input', () => {
  document.getElementById('degreeValue').textContent = document.getElementById('maxDegree').value;
  updateURL();
});

// ---------------- Random helpers ----------------
const pick = a => a[Math.floor(Math.random() * a.length)];
const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
const randDecimal = (a, b) => {
  let val = (Math.random() * (b - a) + a).toFixed(1);
  return parseFloat(val);
};

// ---------------- GCD für Brüche ----------------
function gcd(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);
  while(b) {
    let t = b;
    b = a % b;
    a = t;
  }
  return a;
}

function simplifyFraction(num, den) {
  let g = gcd(num, den);
  return [num / g, den / g];
}

// ---------------- Coefficient Generator ----------------
function generateCoeff(isExtraFactor = false) {
  let allowDec = document.getElementById('allowDecimals').checked;
  let allowFrac = document.getElementById('allowFractions').checked;
  
  if(isExtraFactor) {
    // Extra-Faktoren: sehr groß, sehr klein, oder als Bruch/Dezimal
    let choice = Math.random();
    if(choice < 0.4) {
      // Sehr große Zahl
      let val = rand(100, 9999) * (Math.random() < 0.5 ? 1 : -1);
      return { type: 'integer', value: val };
    } else if(choice < 0.7) {
      // Bruch
      let num = rand(1, 9) * (Math.random() < 0.5 ? 1 : -1);
      let den = rand(10, 999);
      let [n, d] = simplifyFraction(num, den);
      return { type: 'fraction', num: n, den: d };
    } else {
      // Kleine Dezimalzahl
      let val = (Math.random() * 0.99 + 0.01) * (Math.random() < 0.5 ? 1 : -1);
      val = parseFloat(val.toFixed(2));
      return { type: 'decimal', value: val };
    }
  }
  
  if(allowFrac && Math.random() < 0.3) {
    let num = rand(-9, 9);
    if(num === 0) num = 1;
    let den = rand(2, 9);
    let [n, d] = simplifyFraction(num, den);
    return { type: 'fraction', num: n, den: d };
  } else if(allowDec && Math.random() < 0.3) {
    let val = parseFloat(randDecimal(-9, 9));
    if(val === 0) val = 1;
    return { type: 'decimal', value: val };
  } else {
    let val = rand(-9, 9);
    return { type: 'integer', value: val };
  }
}

function coeffToString(coeff, skipOne = false) {
  if(coeff.type === 'fraction') {
    if(coeff.num === 0) return '0';
    let absNum = Math.abs(coeff.num);
    let absDen = Math.abs(coeff.den);
    
    // Ganzzahliger Bruch (z.B. 3/1 oder 6/2=3)
    if(absDen === 1) {
      let val = coeff.num < 0 ? -absNum : absNum;
      if(skipOne && Math.abs(val) === 1) return val < 0 ? '-' : '';
      return val.toString();
    }
    
    if(skipOne && absNum === absDen) return coeff.num < 0 ? '-' : '';
    let sign = coeff.num < 0 ? '-' : '';
    return `${sign}\\frac{${absNum}}{${absDen}}`;
  } else if(coeff.type === 'decimal') {
    if(coeff.value === 0) return '0';
    if(skipOne && coeff.value === 1) return '';
    if(skipOne && coeff.value === -1) return '-';
    return coeff.value.toString().replace('.', '{,}');
  } else {
    if(coeff.value === 0) return '0';
    if(skipOne && coeff.value === 1) return '';
    if(skipOne && coeff.value === -1) return '-';
    return coeff.value.toString();
  }
}

function coeffIsZero(coeff) {
  if(coeff.type === 'fraction') return coeff.num === 0;
  return coeff.value === 0;
}

function coeffIsNegative(coeff) {
  if(coeff.type === 'fraction') return coeff.num < 0;
  return coeff.value < 0;
}

function multiplyCoeff(coeff, factor) {
  if(coeff.type === 'fraction') {
    let newNum = coeff.num * factor;
    let [n, d] = simplifyFraction(newNum, coeff.den);
    return { type: 'fraction', num: n, den: d };
  } else if(coeff.type === 'decimal') {
    return { type: 'decimal', value: coeff.value * factor };
  } else {
    return { type: 'integer', value: coeff.value * factor };
  }
}

// ---------------- Current Expression ----------------
let currentExpr = '';

function openSteps(){
  const url = 'https://www.ableitungsrechner.net/#expr=' + encodeURIComponent(currentExpr) + '&showsteps=1';
  window.open(url, '_blank');
}

// ---------------- Task Generator ----------------
function newTask(){
  // Alle Details-Elemente schließen (auch den neuen Zwischenschritt)
  document.querySelectorAll('details').forEach(d => d.removeAttribute('open'));
  
  let funcType = document.querySelector('input[name="funcType"]:checked').value;
  let maxDeg = parseInt(document.getElementById('maxDegree').value);
  let allowFactor = document.getElementById('allowFactor').checked;
  
  let coeffs = [];
  let degree;
  
  if(funcType === 'power') {
    // Nur eine Potenzfunktion: x^n (OHNE Koeffizient)
    degree = rand(1, maxDeg);
    for(let i = 0; i <= maxDeg; i++) {
      if(i === degree) {
        coeffs.push({ type: 'integer', value: 1 }); // Nur Koeffizient 1
      } else {
        coeffs.push({ type: 'integer', value: 0 });
      }
    }
    allowFactor = false; // Kein Faktor bei reinen Potenzfunktionen
  } else if(funcType === 'powerWithFactor') {
    // Potenzfunktion mit Faktorregel - a·x^n (OHNE Extra-Faktor in Klammern)
    degree = rand(1, maxDeg);
    for(let i = 0; i <= maxDeg; i++) {
      if(i === degree) {
        let c;
        do {
          c = generateCoeff(false);
        } while(coeffIsZero(c));
        coeffs.push(c);
      } else {
        coeffs.push({ type: 'integer', value: 0 });
      }
    }
    allowFactor = false; // KEIN Extra-Faktor für Faktorregel
  } else {
    // Polynom
    degree = rand(1, maxDeg);
    for(let i = 0; i <= degree; i++) {
      if(i === degree) {
        // Höchster Koeffizient darf nicht 0 sein
        let c;
        do {
          c = generateCoeff(false);
        } while(coeffIsZero(c));
        coeffs.push(c);
      } else {
        coeffs.push(generateCoeff(false));
      }
    }
  }
  
  // Extra Faktor
  let factor = null;
  if(allowFactor && Math.random() < 0.4) {
    // Nur bei Polynomen möglich
    factor = generateCoeff(true);
    while(coeffIsZero(factor)) {
      factor = generateCoeff(true);
    }
  }
  
  // Build f(x)
  let fTerms = [];
  for(let i = coeffs.length - 1; i >= 0; i--) {
    let pow = i;
    let c = coeffs[i];
    
    if(coeffIsZero(c)) continue;
    
    let term = '';
    let cStr = coeffToString(c, pow > 0);
    
    if(pow === 0) {
      term = coeffToString(c, false);
    } else if(pow === 1) {
      if(cStr === '') term = 'x';
      else if(cStr === '-') term = '-x';
      else term = cStr + 'x';
    } else {
      if(cStr === '') term = `x^{${pow}}`;
      else if(cStr === '-') term = `-x^{${pow}}`;
      else term = cStr + `x^{${pow}}`;
    }
    
    fTerms.push({ term, isNegative: coeffIsNegative(c) });
  }
  
  let f = '';
  for(let i = 0; i < fTerms.length; i++) {
    if(i === 0) {
      f += fTerms[i].term;
    } else {
      if(fTerms[i].isNegative) {
        f += fTerms[i].term;
      } else {
        f += '+' + fTerms[i].term;
      }
    }
  }
  
  // Fallback falls f leer ist
  if(f === '') f = 'x';
  
  // Build derivative (intermediate step) - Koeffizient · Exponent · x^(n-1)
  let intermediateTerms = [];
  for(let i = coeffs.length - 1; i >= 0; i--) {
    let pow = i;
    let c = coeffs[i];
    
    if(coeffIsZero(c) || pow === 0) continue;
    
    let cStr = coeffToString(c, false);
    let term = '';
    
    if(pow === 1) {
      // Nur der Koeffizient bleibt übrig
      term = cStr;
    } else if(pow === 2) {
      // Koeffizient · 2 · x
      term = `${cStr}\\cdot ${pow}\\cdot x`;
    } else {
      // Koeffizient · Exponent · x^(n-1)
      term = `${cStr}\\cdot ${pow}\\cdot x^{${pow-1}}`;
    }
    
    intermediateTerms.push({ term, isNegative: coeffIsNegative(c) });
  }
  
  let intermediate = '';
  for(let i = 0; i < intermediateTerms.length; i++) {
    if(i === 0) {
      intermediate += intermediateTerms[i].term;
    } else {
      if(intermediateTerms[i].isNegative) {
        intermediate += intermediateTerms[i].term;
      } else {
        intermediate += '+' + intermediateTerms[i].term;
      }
    }
  }
  
  // Build derivative (final)
  let dTerms = [];
  for(let i = coeffs.length - 1; i >= 0; i--) {
    let pow = i;
    let c = coeffs[i];
    
    if(coeffIsZero(c) || pow === 0) continue;
    
    let newC = multiplyCoeff(c, pow);
    let newPow = pow - 1;
    
    let term = '';
    let cStr = coeffToString(newC, newPow > 0);
    
    if(newPow === 0) {
      term = coeffToString(newC, false);
    } else if(newPow === 1) {
      if(cStr === '') term = 'x';
      else if(cStr === '-') term = '-x';
      else term = cStr + 'x';
    } else {
      if(cStr === '') term = `x^{${newPow}}`;
      else if(cStr === '-') term = `-x^{${newPow}}`;
      else term = cStr + `x^{${newPow}}`;
    }
    
    dTerms.push({ term, isNegative: coeffIsNegative(newC) });
  }
  
  let d = '';
  for(let i = 0; i < dTerms.length; i++) {
    if(i === 0) {
      d += dTerms[i].term;
    } else {
      if(dTerms[i].isNegative) {
        d += dTerms[i].term;
      } else {
        d += '+' + dTerms[i].term;
      }
    }
  }
  
  if(d === '') d = '0';
  if(intermediate === '') intermediate = '0';
  
  // Apply factor if present
  let taskStr = '';
  let intermediateStr = '';
  let solutionStr = '';
  
  if(factor) {
    let factorStr = coeffToString(factor, false);
    taskStr = `${factorStr}\\left(${f}\\right)`;
    
    // Zwischenschritt: Faktor bleibt stehen, aber innere Ableitung zeigt Zwischenschritt
    intermediateStr = `${factorStr}\\left(${intermediate}\\right)`;
    
    // Lösung: Faktor bleibt stehen, innere Ableitung vereinfacht
    solutionStr = `${factorStr}\\left(${d}\\right)`;
    
    currentExpr = factorStr.replace('{,}', '.') + '(' + f + ')';
  } else {
    taskStr = f;
    intermediateStr = intermediate;
    solutionStr = d;
    currentExpr = f;
  }
  
  document.getElementById('task').innerHTML = `$$f(x)=${taskStr}$$`;
  document.getElementById('solutionPathContent').innerHTML = `<b>Zwischenschritt:</b><br>$$f'(x)=${intermediateStr}$$`;
  document.getElementById('solution').innerHTML = `$$f'(x)=${solutionStr}$$`;
  
  MathJax.typesetPromise().then(() => scaleAllElements());
}

document.getElementById('solutionPath')?.addEventListener('toggle', () => {
  if (window.MathJax) MathJax.typesetPromise().then(() => scaleToFit(document.getElementById('solutionPathContent')));
});

MathJax.startup.promise.then(() => newTask());
</script>

</body>
</html>
